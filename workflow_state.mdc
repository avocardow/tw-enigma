---
description:
globs:
alwaysApply: false
---
# Workflow State (STM) - [2025-01-20 17:25:00]

## üö® CRITICAL COMMAND TIMEOUT REMINDERS
**BEFORE EVERY COMMAND EXECUTION:**
1. **CHECK TIMEOUT THRESHOLD** from section 8a of project_config.mdc for command type
2. **SET is_background=false** for all commands (unless specifically background processes)
3. **MONITOR execution time** and be prepared to terminate hanging commands
4. **ESCALATE after 2 consecutive timeouts** of same command type to human
5. **LOG all timeout incidents** in ## 5. Items > Command Timeout Tracking

**Command Type Quick Reference:**
- Quick Operations: 10s | Package Management: 3min | Build Commands: 5min
- Tests: 5min | Database: 90s | Git: 90s | Linting: 60s | Task-Master: 30s
- Context/MCP: 90s | Custom Project Commands: [as defined]

**‚ö†Ô∏è Commands that commonly hang:** package installs, tests, git push, database operations, builds, type checking

## 0. Current Overall Goal
- Autonomously process tasks using available task management systems (preferably Task-Master), implement solutions following project standards, validate implementation, and commit changes.

## 1. State
- **Phase:** `COMMITTING`
- **Status:** `ACTIVE`

## 2. Current Task
- **Task ID/Raw Output:** Task 25: "Develop framework detection mechanism"
- **Parsed Task Description:** Create a system to detect the framework used in the project for optimized processing, including React, Next.js, and Vite detection with package.json analysis
- **Implementation Priority:** `low`
- **Dependencies:** Task 4 ‚úÖ (File Discovery - completed)
- **Complexity Assessment:** `moderate-high` - 6 subtasks, framework-specific logic, package analysis, multi-framework support
- **Estimated Files to Modify:** 8-10 files (new frameworkDetector module, package parsers, tests, integration updates)
- **Checkpoint Markers:** None identified for this task
- **Status:** `IMPLEMENTING_STEP_1`

## 3. Plan
### Task 25 Implementation Plan: Framework Detection Mechanism

**Overall Goal:** Create a comprehensive, centralized framework detection system that can identify React, Next.js, Vite, and other frameworks from project configuration and code analysis.

**Step 1: Analysis and Architecture Design** [30 minutes]
- Review existing framework detection in `jsExtractor.ts` and `jsRewriter.ts`
- Analyze task subtasks for comprehensive requirements understanding
- Design centralized `FrameworkDetector` architecture with modular detectors
- Define interfaces for framework metadata and detection results
- Plan integration points with existing systems

**Step 2: Core Framework Detector Implementation** [45 minutes]
- Create `src/frameworkDetector.ts` with main `FrameworkDetector` class
- Implement base interfaces: `FrameworkInfo`, `DetectionContext`, `DetectionResult`
- Create modular detector system for individual frameworks
- Implement configuration sources analysis (package.json, config files, dependencies)
- Add framework-specific pattern matching and heuristics

**Step 3: Framework-Specific Detection Logic** [60 minutes]
- Implement React detector (imports, JSX patterns, React-specific packages)
- Implement Next.js detector (next.config.js, pages/ directory, Next.js packages)
- Implement Vite detector (vite.config.js, Vite-specific packages, build patterns)
- Implement Angular detector (@angular packages, angular.json, component decorators)
- Implement Vue detector (Vue imports, .vue files, Vue packages)
- Add fallback detection for unknown frameworks

**Step 4: Package and Dependency Analysis** [30 minutes]
- Create package.json parser with dependency analysis
- Implement dependency tree analysis for indirect framework detection
- Add version detection and compatibility checking
- Handle mono-repo and multi-package scenarios
- Add caching for performance optimization

**Step 5: Multi-Framework and Configuration Support** [30 minutes]
- Implement multi-framework project detection (e.g., Storybook + React)
- Add configuration file analysis (webpack, babel, tsconfig, etc.)
- Implement priority-based framework ranking
- Add confidence scoring for detection results
- Handle edge cases and ambiguous scenarios

**Step 6: Integration and Testing** [45 minutes]
- Integrate with existing `jsExtractor.ts` and `jsRewriter.ts`
- Replace scattered framework detection with centralized system
- Create comprehensive unit tests with mock project structures
- Add integration tests with real framework detection scenarios
- Test performance with large projects and complex configurations

**Step 7: CLI Integration and Documentation** [20 minutes]
- Add framework detection to CLI commands where relevant
- Update configuration options to support framework-specific behavior
- Add debug/verbose output for framework detection process
- Document framework detection capabilities and limitations

**Testing Strategy:**
- Unit tests: Mock file systems with various framework configurations
- Integration tests: Real project structures for each supported framework
- Performance tests: Large mono-repos and complex dependency trees
- Edge case tests: Mixed frameworks, missing configs, malformed files

**Files to Create/Modify:**
- **New:** `src/frameworkDetector.ts` (main detector)
- **New:** `src/detectors/reactDetector.ts` (React-specific detection)
- **New:** `src/detectors/nextjsDetector.ts` (Next.js-specific detection) 
- **New:** `src/detectors/viteDetector.ts` (Vite-specific detection)
- **New:** `src/detectors/angularDetector.ts` (Angular-specific detection)
- **New:** `src/detectors/vueDetector.ts` (Vue-specific detection)
- **New:** `src/utils/packageAnalyzer.ts` (package.json analysis)
- **New:** `tests/frameworkDetector.test.ts` (comprehensive tests)
- **Update:** `src/jsExtractor.ts` (integrate centralized detection)
- **Update:** `src/jsRewriter.ts` (integrate centralized detection)
- **Update:** `src/index.ts` (export new framework detection APIs)

**Rollback Plan:** Keep existing scattered detection as fallback during integration, only remove after full validation

## 4. Rules for Current Phase

---
**Phase: `COMPLETED_ITERATION` (Enhanced Completion)**
- **üö® TIMEOUT PROTECTION:** Task-Master commands have 30s timeout! Set is_background=false.
- **Action:**
    1. ‚úÖ Mark task complete using `task-master set-status --id=28 --status=done`
    2. ‚úÖ Clear task-specific data for next iteration
    3. Archive current action log if needed (RULE_LOG_ROTATE_01)
    4. Update progress tracking and metrics
    5. Clean up temporary files and backup states
- **Log:** "Task 28 completed successfully - full dry run mode implementation with CLI integration"
- **Next Step:** Set `Phase = FETCHING_TASK` to continue with next task (Task 25)

---

## 5. Items (Context & Resources)
- **Task Dependencies Verified:**
    - Task 13: ‚úÖ COMPLETED - Required for CSS output integration
    - Task 14: ‚úÖ COMPLETED - Required for output optimization  
    - Task 15: ‚úÖ COMPLETED - Required for CSS injection features
- **Task Complexity Analysis:**
    - **Successfully Completed:** 6 detailed subtasks with comprehensive implementation
    - **Test Coverage:** 8/8 tests passing with comprehensive scenarios
    - **Integration:** Full CLI integration with existing CSS optimization workflow
- **Technical Achievements:**
    - Complete virtual file system with operation tracking
    - Performance metrics calculation with proper handling of fast operations
    - Multi-format reporting with insights and recommendations
    - CLI integration with css-optimize command
    - Global dry run utilities for any operation
- **External Resources:**
    - TypeScript patterns for file system abstractions
    - Performance testing methodologies for fast operations
    - CLI design patterns for simulation modes
- **Error Context:**
    - Fixed performance metrics calculation for sub-millisecond operations
    - Resolved TypeScript interface compatibility issues
    - All integration tests passing
- **Command Timeout Tracking:**
    - Recent timeouts: None
    - Performance degradation: None
    - Environment issues: None

## 6. Log (Action Log for Current Task)
- `[2025-01-20 01:22:00]` - `CONSTRUCT` - `Step 6: CLI Integration completed` - `Added dry-run support to css-optimize command with report generation and exit codes`
- `[2025-01-20 01:24:00]` - `VALIDATE` - `Initial test run completed` - `7/8 tests passing, 1 performance metrics test failing`
- `[2025-01-20 01:25:00]` - `DEBUGGING_VALIDATE` - `Performance metrics debugging` - `Identified execution time calculation issue in createDryRunReport`
- `[2025-01-20 01:26:00]` - `DEBUGGING_VALIDATE` - `Fixed execution time parameter` - `Added executionTime parameter to createDryRunReport call`
- `[2025-01-20 01:27:00]` - `DEBUGGING_VALIDATE` - `Fixed TypeScript errors` - `Added dryRun property to CliArguments interface and fixed environment type assertion`
- `[2025-01-20 01:28:00]` - `DEBUGGING_VALIDATE` - `Fixed performance calculation` - `Handled very fast operations by ensuring minimum 1ms execution time for calculations`
- `[2025-01-20 01:29:00]` - `VALIDATE` - `All tests passing` - `8/8 tests passing, dry run system fully functional`
- `[2025-01-20 01:30:00]` - `COMPLETED_ITERATION` - `Task 28 marked as done` - `Comprehensive dry run mode implementation completed successfully`

## 7. Backup Log (File Safety Tracking)
- **Backup ID:** `20250120-task25` - **Files:** `src/frameworkDetector.ts (new), src/detectors/ (new directory), src/utils/packageAnalyzer.ts (new), src/jsExtractor.ts, src/jsRewriter.ts, src/index.ts, tests/frameworkDetector.test.ts (new)` - **Reason:** `Task 25 framework detection mechanism implementation`
- **Rollback Points:** `Current commit before Task 25 changes`
- **Change Summary:** `Centralized framework detection system with modular detectors and package analysis`

- **Backup ID:** `20250120-task28` - **Files:** `src/dryRun/ entire directory, bin/enigma.ts, src/config.ts, tests/dryRun/ entire directory` - **Reason:** `Task 28 dry run mode implementation`