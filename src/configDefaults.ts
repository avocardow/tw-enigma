/**\n * Copyright (c) 2025 Rowan Cardow\n * \n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { z } from 'zod';\nimport { createLogger } from './logger.js';\nimport type { EnigmaConfig } from './config.js';\nimport { PERFORMANCE_CONSTRAINTS } from './configValidator.js';\nimport * as os from 'os';\nimport * as path from 'path';\nimport * as fs from 'fs';\n\nconst logger = createLogger('ConfigDefaults');\n\n/**\n * Context for intelligent default calculation\n */\nexport interface DefaultsContext {\n  systemCpuCount: number;\n  systemMemoryMB: number;\n  workingDirectory: string;\n  nodeVersion: string;\n  platform: string;\n  projectSize?: 'small' | 'medium' | 'large';\n  estimatedFileCount?: number;\n}\n\n/**\n * Safe mode configuration profiles\n */\nexport const SAFE_MODE_PROFILES = {\n  minimal: {\n    name: 'Minimal Safety',\n    description: 'Basic safety with minimal performance impact',\n    maxConcurrency: 2,\n    maxFileSize: 1024 * 1024, // 1MB\n    timeout: 5000,\n    enableBackups: false,\n    enableValidation: true,\n  },\n  balanced: {\n    name: 'Balanced Safety',\n    description: 'Good balance of safety and performance',\n    maxConcurrency: 4,\n    maxFileSize: 10 * 1024 * 1024, // 10MB\n    timeout: 10000,\n    enableBackups: true,\n    enableValidation: true,\n  },\n  strict: {\n    name: 'Strict Safety',\n    description: 'Maximum safety with comprehensive validation',\n    maxConcurrency: 2,\n    maxFileSize: 5 * 1024 * 1024, // 5MB\n    timeout: 30000,\n    enableBackups: true,\n    enableValidation: true,\n  },\n  performance: {\n    name: 'Performance Optimized',\n    description: 'Optimized for performance with basic safety',\n    maxConcurrency: 8,\n    maxFileSize: 50 * 1024 * 1024, // 50MB\n    timeout: 15000,\n    enableBackups: false,\n    enableValidation: false,\n  },\n} as const;\n\nexport type SafeModeProfile = keyof typeof SAFE_MODE_PROFILES;\n\n/**\n * Fallback configuration for dangerous settings\n */\nexport interface FallbackConfig {\n  reason: string;\n  originalValue: any;\n  fallbackValue: any;\n  severity: 'warning' | 'error' | 'critical';\n  autoApplied: boolean;\n}\n\n/**\n * Configuration safety validator and defaults manager\n */\nexport class ConfigSafetyManager {\n  private context: DefaultsContext;\n  private logger = createLogger('ConfigSafetyManager');\n  private fallbacks: FallbackConfig[] = [];\n  \n  constructor(context?: Partial<DefaultsContext>) {\n    this.context = this.createContext(context);\n    this.logger.debug('Safety manager initialized', {\n      context: this.context\n    });\n  }\n\n  /**\n   * Create system context for intelligent defaults\n   */\n  private createContext(override?: Partial<DefaultsContext>): DefaultsContext {\n    const cpuCount = os.cpus().length;\n    const totalMemory = os.totalmem() / 1024 / 1024; // MB\n    \n    return {\n      systemCpuCount: cpuCount,\n      systemMemoryMB: totalMemory,\n      workingDirectory: process.cwd(),\n      nodeVersion: process.version,\n      platform: process.platform,\n      ...override\n    };\n  }\n\n  /**\n   * Generate intelligent default configuration\n   */\n  generateIntelligentDefaults(): Partial<EnigmaConfig> {\n    this.logger.debug('Generating intelligent defaults', {\n      context: this.context\n    });\n    \n    const defaults: Partial<EnigmaConfig> = {\n      // Performance defaults based on system\n      maxConcurrency: this.calculateOptimalConcurrency(),\n      \n      // Memory-conscious defaults\n      htmlExtractor: {\n        maxFileSize: this.calculateMaxFileSize(),\n        timeout: this.calculateTimeout(),\n        caseSensitive: false,\n        ignoreEmpty: true,\n        preserveWhitespace: false,\n      },\n      \n      jsExtractor: {\n        maxFileSize: this.calculateMaxFileSize(),\n        timeout: this.calculateTimeout(),\n        enableFrameworkDetection: true,\n        includeDynamicClasses: false,\n        caseSensitive: false,\n        ignoreEmpty: true,\n        supportedFrameworks: ['react', 'vue', 'angular', 'svelte'],\n      },\n      \n      cssInjector: {\n        maxFileSize: this.calculateMaxFileSize(),\n        timeout: this.calculateTimeout(),\n        useRelativePaths: true,\n        preventDuplicates: true,\n        insertPosition: 'after-meta',\n        createBackup: this.shouldEnableBackups(),\n      },\n      \n      fileIntegrity: {\n        algorithm: 'sha256',\n        createBackups: this.shouldEnableBackups(),\n        backupRetentionDays: 7,\n        maxFileSize: this.calculateMaxFileSize(),\n        timeout: this.calculateTimeout(),\n        verifyAfterRollback: true,\n        batchSize: this.calculateBatchSize(),\n        enableCaching: true,\n        cacheSize: this.calculateCacheSize(),\n        enableCompression: this.shouldEnableCompression(),\n        compressionAlgorithm: 'gzip',\n        compressionLevel: 6,\n        compressionThreshold: 1024,\n      },\n      \n      // Safety defaults\n      verbose: false,\n      debug: false,\n      pretty: false,\n      minify: true,\n      removeUnused: true,\n      preserveComments: false,\n      sourceMaps: false,\n      \n      // Discovery defaults\n      followSymlinks: false,\n      maxFiles: this.calculateMaxFiles(),\n      excludeExtensions: ['.tmp', '.temp', '.log', '.bak'],\n      excludePatterns: [\n        'node_modules/**',\n        '.git/**',\n        'dist/**',\n        'build/**',\n        '**/*.test.*',\n        '**/*.spec.*',\n      ],\n    };\n    \n    this.logger.info('Generated intelligent defaults', {\n      maxConcurrency: defaults.maxConcurrency,\n      maxFileSize: Math.round((defaults.htmlExtractor?.maxFileSize || 0) / 1024 / 1024),\n      enableBackups: defaults.cssInjector?.createBackup,\n      enableCompression: defaults.fileIntegrity?.enableCompression\n    });\n    \n    return defaults;\n  }\n\n  /**\n   * Apply safe mode profile\n   */\n  applySafeModeProfile(profile: SafeModeProfile): Partial<EnigmaConfig> {\n    const profileConfig = SAFE_MODE_PROFILES[profile];\n    this.logger.info('Applying safe mode profile', {\n      profile,\n      description: profileConfig.description\n    });\n    \n    return {\n      maxConcurrency: profileConfig.maxConcurrency,\n      htmlExtractor: {\n        maxFileSize: profileConfig.maxFileSize,\n        timeout: profileConfig.timeout,\n        caseSensitive: false,\n        ignoreEmpty: true,\n        preserveWhitespace: false,\n      },\n      jsExtractor: {\n        maxFileSize: profileConfig.maxFileSize,\n        timeout: profileConfig.timeout,\n        enableFrameworkDetection: profile !== 'performance',\n        includeDynamicClasses: false,\n        caseSensitive: false,\n        ignoreEmpty: true,\n        supportedFrameworks: ['react', 'vue'],\n      },\n      cssInjector: {\n        maxFileSize: profileConfig.maxFileSize,\n        timeout: profileConfig.timeout,\n        useRelativePaths: true,\n        preventDuplicates: true,\n        insertPosition: 'after-meta',\n        createBackup: profileConfig.enableBackups,\n      },\n      fileIntegrity: profileConfig.enableBackups ? {\n        algorithm: 'sha256',\n        createBackups: true,\n        backupRetentionDays: profile === 'strict' ? 14 : 7,\n        maxFileSize: profileConfig.maxFileSize,\n        timeout: profileConfig.timeout,\n        verifyAfterRollback: true,\n        batchSize: Math.min(profileConfig.maxConcurrency * 2, 10),\n        enableCaching: true,\n        cacheSize: profile === 'performance' ? 1000 : 100,\n      } : undefined,\n    };\n  }\n\n  /**\n   * Validate and apply fallbacks for dangerous configurations\n   */\n  validateAndApplyFallbacks(config: EnigmaConfig): EnigmaConfig {\n    this.logger.debug('Validating configuration for safety issues');\n    this.fallbacks = [];\n    \n    let safeConfig = { ...config };\n    \n    // Check concurrency limits\n    safeConfig = this.checkConcurrency(safeConfig);\n    \n    // Check file size limits\n    safeConfig = this.checkFileSizes(safeConfig);\n    \n    // Check timeout values\n    safeConfig = this.checkTimeouts(safeConfig);\n    \n    // Check path safety\n    safeConfig = this.checkPaths(safeConfig);\n    \n    // Check memory constraints\n    safeConfig = this.checkMemoryConstraints(safeConfig);\n    \n    if (this.fallbacks.length > 0) {\n      this.logger.warn('Applied safety fallbacks', {\n        fallbackCount: this.fallbacks.length,\n        fallbacks: this.fallbacks.map(f => ({ reason: f.reason, severity: f.severity }))\n      });\n    }\n    \n    return safeConfig;\n  }\n\n  /**\n   * Get applied fallbacks\n   */\n  getFallbacks(): FallbackConfig[] {\n    return [...this.fallbacks];\n  }\n\n  /**\n   * Calculate optimal concurrency based on system\n   */\n  private calculateOptimalConcurrency(): number {\n    const cpuCount = this.context.systemCpuCount;\n    const memoryGB = this.context.systemMemoryMB / 1024;\n    \n    // Conservative approach: leave at least 1 CPU core free\n    let optimal = Math.max(1, cpuCount - 1);\n    \n    // Adjust for memory constraints\n    if (memoryGB < 4) {\n      optimal = Math.min(optimal, 2);\n    } else if (memoryGB < 8) {\n      optimal = Math.min(optimal, 4);\n    }\n    \n    // Cap at reasonable maximum\n    return Math.min(optimal, PERFORMANCE_CONSTRAINTS.MAX_CONCURRENCY);\n  }\n\n  /**\n   * Calculate appropriate file size limits\n   */\n  private calculateMaxFileSize(): number {\n    const memoryGB = this.context.systemMemoryMB / 1024;\n    \n    if (memoryGB < 4) {\n      return 5 * 1024 * 1024; // 5MB\n    } else if (memoryGB < 8) {\n      return 10 * 1024 * 1024; // 10MB\n    } else {\n      return 20 * 1024 * 1024; // 20MB\n    }\n  }\n\n  /**\n   * Calculate appropriate timeout values\n   */\n  private calculateTimeout(): number {\n    // Base timeout with platform adjustments\n    let timeout = 10000; // 10 seconds base\n    \n    // Adjust for slower platforms\n    if (this.context.platform === 'win32') {\n      timeout *= 1.2; // Windows can be slower\n    }\n    \n    // Adjust for system specs\n    const memoryGB = this.context.systemMemoryMB / 1024;\n    if (memoryGB < 4) {\n      timeout *= 1.5; // Give more time on low-memory systems\n    }\n    \n    return Math.min(timeout, PERFORMANCE_CONSTRAINTS.MAX_TIMEOUT_MS);\n  }\n\n  /**\n   * Should enable backups based on system and project context\n   */\n  private shouldEnableBackups(): boolean {\n    const freeSpace = this.estimateFreeDiskSpace();\n    const hasSpace = freeSpace > 1024; // At least 1GB free\n    \n    // Enable backups if we have space and it's not a temporary/test environment\n    return hasSpace && !this.context.workingDirectory.includes('temp');\n  }\n\n  /**\n   * Should enable compression based on system specs\n   */\n  private shouldEnableCompression(): boolean {\n    const cpuCount = this.context.systemCpuCount;\n    const memoryGB = this.context.systemMemoryMB / 1024;\n    \n    // Enable compression if we have sufficient resources\n    return cpuCount >= 4 && memoryGB >= 4;\n  }\n\n  /**\n   * Calculate batch size for file operations\n   */\n  private calculateBatchSize(): number {\n    const concurrency = this.calculateOptimalConcurrency();\n    return Math.min(concurrency * 2, 20);\n  }\n\n  /**\n   * Calculate cache size based on available memory\n   */\n  private calculateCacheSize(): number {\n    const memoryGB = this.context.systemMemoryMB / 1024;\n    \n    if (memoryGB < 4) {\n      return 50;\n    } else if (memoryGB < 8) {\n      return 100;\n    } else {\n      return 500;\n    }\n  }\n\n  /**\n   * Calculate maximum files to process\n   */\n  private calculateMaxFiles(): number {\n    const memoryGB = this.context.systemMemoryMB / 1024;\n    \n    if (memoryGB < 4) {\n      return 1000;\n    } else if (memoryGB < 8) {\n      return 5000;\n    } else {\n      return 10000;\n    }\n  }\n\n  /**\n   * Estimate free disk space (simplified)\n   */\n  private estimateFreeDiskSpace(): number {\n    try {\n      // This is a simplified approach - in production might use statvfs or similar\n      return 10000; // 10GB assumption\n    } catch {\n      return 1000; // 1GB fallback\n    }\n  }\n\n  /**\n   * Check and fix concurrency issues\n   */\n  private checkConcurrency(config: EnigmaConfig): EnigmaConfig {\n    const optimal = this.calculateOptimalConcurrency();\n    \n    if (config.maxConcurrency > PERFORMANCE_CONSTRAINTS.MAX_CONCURRENCY) {\n      this.fallbacks.push({\n        reason: `Concurrency too high (${config.maxConcurrency} > ${PERFORMANCE_CONSTRAINTS.MAX_CONCURRENCY})`,\n        originalValue: config.maxConcurrency,\n        fallbackValue: optimal,\n        severity: 'error',\n        autoApplied: true\n      });\n      \n      return { ...config, maxConcurrency: optimal };\n    }\n    \n    if (config.maxConcurrency > this.context.systemCpuCount * 2) {\n      this.fallbacks.push({\n        reason: `Concurrency exceeds system capacity (${config.maxConcurrency} > ${this.context.systemCpuCount * 2})`,\n        originalValue: config.maxConcurrency,\n        fallbackValue: optimal,\n        severity: 'warning',\n        autoApplied: true\n      });\n      \n      return { ...config, maxConcurrency: optimal };\n    }\n    \n    return config;\n  }\n\n  /**\n   * Check and fix file size issues\n   */\n  private checkFileSizes(config: EnigmaConfig): EnigmaConfig {\n    const maxSafeSize = this.calculateMaxFileSize();\n    let updatedConfig = { ...config };\n    \n    const checkAndFixFileSize = (value: number | undefined, path: string) => {\n      if (value && value > PERFORMANCE_CONSTRAINTS.MAX_FILE_SIZE_MB * 1024 * 1024) {\n        this.fallbacks.push({\n          reason: `File size limit too high at ${path} (${Math.round(value / 1024 / 1024)}MB)`,\n          originalValue: value,\n          fallbackValue: maxSafeSize,\n          severity: 'error',\n          autoApplied: true\n        });\n        return maxSafeSize;\n      }\n      return value;\n    };\n    \n    if (updatedConfig.htmlExtractor) {\n      updatedConfig.htmlExtractor.maxFileSize = checkAndFixFileSize(\n        updatedConfig.htmlExtractor.maxFileSize,\n        'htmlExtractor.maxFileSize'\n      );\n    }\n    \n    if (updatedConfig.jsExtractor) {\n      updatedConfig.jsExtractor.maxFileSize = checkAndFixFileSize(\n        updatedConfig.jsExtractor.maxFileSize,\n        'jsExtractor.maxFileSize'\n      );\n    }\n    \n    if (updatedConfig.cssInjector) {\n      updatedConfig.cssInjector.maxFileSize = checkAndFixFileSize(\n        updatedConfig.cssInjector.maxFileSize,\n        'cssInjector.maxFileSize'\n      );\n    }\n    \n    if (updatedConfig.fileIntegrity) {\n      updatedConfig.fileIntegrity.maxFileSize = checkAndFixFileSize(\n        updatedConfig.fileIntegrity.maxFileSize,\n        'fileIntegrity.maxFileSize'\n      );\n    }\n    \n    return updatedConfig;\n  }\n\n  /**\n   * Check and fix timeout issues\n   */\n  private checkTimeouts(config: EnigmaConfig): EnigmaConfig {\n    const maxSafeTimeout = this.calculateTimeout();\n    let updatedConfig = { ...config };\n    \n    const checkAndFixTimeout = (value: number | undefined, path: string) => {\n      if (value && value > PERFORMANCE_CONSTRAINTS.MAX_TIMEOUT_MS) {\n        this.fallbacks.push({\n          reason: `Timeout too high at ${path} (${value}ms)`,\n          originalValue: value,\n          fallbackValue: maxSafeTimeout,\n          severity: 'warning',\n          autoApplied: true\n        });\n        return maxSafeTimeout;\n      }\n      return value;\n    };\n    \n    if (updatedConfig.htmlExtractor) {\n      updatedConfig.htmlExtractor.timeout = checkAndFixTimeout(\n        updatedConfig.htmlExtractor.timeout,\n        'htmlExtractor.timeout'\n      );\n    }\n    \n    if (updatedConfig.jsExtractor) {\n      updatedConfig.jsExtractor.timeout = checkAndFixTimeout(\n        updatedConfig.jsExtractor.timeout,\n        'jsExtractor.timeout'\n      );\n    }\n    \n    if (updatedConfig.cssInjector) {\n      updatedConfig.cssInjector.timeout = checkAndFixTimeout(\n        updatedConfig.cssInjector.timeout,\n        'cssInjector.timeout'\n      );\n    }\n    \n    if (updatedConfig.fileIntegrity) {\n      updatedConfig.fileIntegrity.timeout = checkAndFixTimeout(\n        updatedConfig.fileIntegrity.timeout,\n        'fileIntegrity.timeout'\n      );\n    }\n    \n    return updatedConfig;\n  }\n\n  /**\n   * Check and sanitize paths\n   */\n  private checkPaths(config: EnigmaConfig): EnigmaConfig {\n    // Basic path safety - more comprehensive validation in configValidator\n    if (config.input && config.output && path.resolve(config.input) === path.resolve(config.output)) {\n      this.fallbacks.push({\n        reason: 'Input and output paths are the same',\n        originalValue: config.output,\n        fallbackValue: config.output + '.processed',\n        severity: 'critical',\n        autoApplied: true\n      });\n      \n      return { ...config, output: config.output + '.processed' };\n    }\n    \n    return config;\n  }\n\n  /**\n   * Check memory constraints\n   */\n  private checkMemoryConstraints(config: EnigmaConfig): EnigmaConfig {\n    const availableMemoryMB = this.context.systemMemoryMB;\n    const estimatedUsage = this.estimateMemoryUsage(config);\n    \n    if (estimatedUsage > availableMemoryMB * 0.8) {\n      const reducedConcurrency = Math.max(1, Math.floor(config.maxConcurrency / 2));\n      \n      this.fallbacks.push({\n        reason: `Estimated memory usage too high (${estimatedUsage}MB > ${Math.round(availableMemoryMB * 0.8)}MB)`,\n        originalValue: config.maxConcurrency,\n        fallbackValue: reducedConcurrency,\n        severity: 'critical',\n        autoApplied: true\n      });\n      \n      return { ...config, maxConcurrency: reducedConcurrency };\n    }\n    \n    return config;\n  }\n\n  /**\n   * Estimate memory usage of configuration\n   */\n  private estimateMemoryUsage(config: EnigmaConfig): number {\n    let estimated = 50; // Base usage\n    estimated += config.maxConcurrency * 20; // Per concurrent operation\n    \n    if (config.fileIntegrity) estimated += 100;\n    if (config.fileIntegrity?.createBackups) estimated += 50;\n    if (config.fileIntegrity?.enableCaching) estimated += (config.fileIntegrity.cacheSize || 100) * 0.1;\n    \n    return estimated;\n  }\n}\n\n/**\n * Create a safety manager with system context\n */\nexport function createSafetyManager(context?: Partial<DefaultsContext>): ConfigSafetyManager {\n  return new ConfigSafetyManager(context);\n}\n\n/**\n * Generate intelligent defaults for the current system\n */\nexport function generateSystemDefaults(): Partial<EnigmaConfig> {\n  const manager = createSafetyManager();\n  return manager.generateIntelligentDefaults();\n}\n\n/**\n * Apply safe mode configuration\n */\nexport function applySafeMode(profile: SafeModeProfile = 'balanced'): Partial<EnigmaConfig> {\n  const manager = createSafetyManager();\n  return manager.applySafeModeProfile(profile);\n} 