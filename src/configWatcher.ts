/**\n * Copyright (c) 2025 Rowan Cardow\n * \n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chokidar, { FSWatcher } from 'chokidar';\nimport { EventEmitter } from 'events';\nimport { createLogger } from './logger.js';\nimport { loadConfig, type EnigmaConfig } from './config.js';\nimport { RuntimeConfigValidator, type ValidationResult } from './configValidator.js';\nimport { ConfigSafetyManager, type FallbackConfig } from './configDefaults.js';\nimport * as path from 'path';\nimport * as fs from 'fs';\n\nconst logger = createLogger('ConfigWatcher');\n\n/**\n * Configuration change event interface\n */\nexport interface ConfigChangeEvent {\n  type: 'created' | 'modified' | 'deleted' | 'renamed';\n  filePath: string;\n  previousConfig?: EnigmaConfig;\n  newConfig?: EnigmaConfig;\n  validationResult?: ValidationResult;\n  fallbacks?: FallbackConfig[];\n  timestamp: Date;\n  error?: Error;\n}\n\n/**\n * Watcher configuration options\n */\nexport interface WatcherOptions {\n  enabled: boolean;\n  debounceMs: number;\n  validateOnChange: boolean;\n  applyFallbacks: boolean;\n  backupOnChange: boolean;\n  maxBackups: number;\n  watchDirectories: string[];\n  ignorePatterns: string[];\n  enableRecovery: boolean;\n  recoveryTimeoutMs: number;\n}\n\n/**\n * Default watcher options\n */\nexport const DEFAULT_WATCHER_OPTIONS: WatcherOptions = {\n  enabled: true,\n  debounceMs: 500,\n  validateOnChange: true,\n  applyFallbacks: true,\n  backupOnChange: true,\n  maxBackups: 10,\n  watchDirectories: ['.', './config'],\n  ignorePatterns: [\n    'node_modules/**',\n    '.git/**',\n    '**/*.tmp',\n    '**/*.temp',\n    '**/*.bak',\n    '**/.*',\n  ],\n  enableRecovery: true,\n  recoveryTimeoutMs: 5000,\n};\n\n/**\n * Configuration file watcher and live validator\n */\nexport class ConfigWatcher extends EventEmitter {\n  private watcher?: FSWatcher;\n  private validator: RuntimeConfigValidator;\n  private safetyManager: ConfigSafetyManager;\n  private options: WatcherOptions;\n  private logger = createLogger('ConfigWatcher');\n  private debounceTimers = new Map<string, NodeJS.Timeout>();\n  private isWatching = false;\n  private backupDirectory: string;\n  private lastValidConfig?: EnigmaConfig;\n  private recoveryTimer?: NodeJS.Timeout;\n  \n  constructor(\n    validator: RuntimeConfigValidator,\n    safetyManager: ConfigSafetyManager,\n    options: Partial<WatcherOptions> = {}\n  ) {\n    super();\n    this.validator = validator;\n    this.safetyManager = safetyManager;\n    this.options = { ...DEFAULT_WATCHER_OPTIONS, ...options };\n    this.backupDirectory = path.join(process.cwd(), '.enigma', 'config-backups');\n    \n    this.logger.debug('Config watcher initialized', {\n      options: this.options,\n      backupDirectory: this.backupDirectory\n    });\n    \n    // Ensure backup directory exists\n    this.ensureBackupDirectory();\n  }\n\n  /**\n   * Start watching configuration files\n   */\n  async startWatching(configPaths?: string[]): Promise<void> {\n    if (this.isWatching) {\n      this.logger.warn('Watcher already running');\n      return;\n    }\n    \n    if (!this.options.enabled) {\n      this.logger.info('Config watching disabled');\n      return;\n    }\n    \n    try {\n      const pathsToWatch = configPaths || this.getDefaultConfigPaths();\n      \n      this.logger.info('Starting configuration file watcher', {\n        paths: pathsToWatch,\n        options: this.options\n      });\n      \n      this.watcher = chokidar.watch(pathsToWatch, {\n        ignored: this.options.ignorePatterns,\n        persistent: true,\n        ignoreInitial: false,\n        followSymlinks: false,\n        depth: 3,\n        awaitWriteFinish: {\n          stabilityThreshold: 100,\n          pollInterval: 50\n        }\n      });\n      \n      // Set up event handlers\n      this.setupEventHandlers();\n      \n      this.isWatching = true;\n      this.emit('started', { paths: pathsToWatch });\n      \n    } catch (error) {\n      this.logger.error('Failed to start config watcher', {\n        error: error instanceof Error ? error.message : String(error)\n      });\n      \n      throw new Error(`Failed to start config watcher: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  /**\n   * Stop watching configuration files\n   */\n  async stopWatching(): Promise<void> {\n    if (!this.isWatching) {\n      return;\n    }\n    \n    this.logger.info('Stopping configuration file watcher');\n    \n    // Clear any pending debounce timers\n    for (const timer of this.debounceTimers.values()) {\n      clearTimeout(timer);\n    }\n    this.debounceTimers.clear();\n    \n    // Clear recovery timer\n    if (this.recoveryTimer) {\n      clearTimeout(this.recoveryTimer);\n      this.recoveryTimer = undefined;\n    }\n    \n    // Close watcher\n    if (this.watcher) {\n      await this.watcher.close();\n      this.watcher = undefined;\n    }\n    \n    this.isWatching = false;\n    this.emit('stopped');\n  }\n\n  /**\n   * Force validation of current configuration\n   */\n  async validateCurrentConfig(): Promise<ValidationResult> {\n    try {\n      const config = await loadConfig();\n      return await this.validator.validateConfiguration(config);\n    } catch (error) {\n      this.logger.error('Failed to validate current config', {\n        error: error instanceof Error ? error.message : String(error)\n      });\n      \n      throw error;\n    }\n  }\n\n  /**\n   * Get watcher status\n   */\n  getStatus(): { isWatching: boolean; watchedPaths: string[]; options: WatcherOptions } {\n    return {\n      isWatching: this.isWatching,\n      watchedPaths: this.watcher ? this.watcher.getWatched() && Object.keys(this.watcher.getWatched()) : [],\n      options: this.options\n    };\n  }\n\n  /**\n   * Update watcher options\n   */\n  updateOptions(newOptions: Partial<WatcherOptions>): void {\n    const oldOptions = { ...this.options };\n    this.options = { ...this.options, ...newOptions };\n    \n    this.logger.info('Watcher options updated', {\n      changes: Object.keys(newOptions),\n      oldEnabled: oldOptions.enabled,\n      newEnabled: this.options.enabled\n    });\n    \n    // Restart watcher if enabled state changed\n    if (oldOptions.enabled !== this.options.enabled) {\n      if (this.options.enabled && !this.isWatching) {\n        this.startWatching().catch(error => {\n          this.logger.error('Failed to restart watcher after enabling', { error });\n        });\n      } else if (!this.options.enabled && this.isWatching) {\n        this.stopWatching().catch(error => {\n          this.logger.error('Failed to stop watcher after disabling', { error });\n        });\n      }\n    }\n  }\n\n  /**\n   * Get list of recent config backups\n   */\n  async getBackups(): Promise<{ file: string; timestamp: Date; size: number }[]> {\n    try {\n      const files = await fs.promises.readdir(this.backupDirectory);\n      const backups = [];\n      \n      for (const file of files) {\n        if (file.endsWith('.json') && file.startsWith('config-backup-')) {\n          const filePath = path.join(this.backupDirectory, file);\n          const stats = await fs.promises.stat(filePath);\n          backups.push({\n            file: filePath,\n            timestamp: stats.mtime,\n            size: stats.size\n          });\n        }\n      }\n      \n      return backups.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());\n    } catch (error) {\n      this.logger.error('Failed to list backups', {\n        error: error instanceof Error ? error.message : String(error)\n      });\n      return [];\n    }\n  }\n\n  /**\n   * Restore configuration from backup\n   */\n  async restoreFromBackup(backupPath: string): Promise<void> {\n    try {\n      this.logger.info('Restoring configuration from backup', {\n        backupPath\n      });\n      \n      // Read backup content\n      const backupContent = await fs.promises.readFile(backupPath, 'utf-8');\n      const backupConfig = JSON.parse(backupContent);\n      \n      // Validate backup config\n      const validationResult = await this.validator.validateConfiguration(backupConfig);\n      \n      if (!validationResult.isValid) {\n        throw new Error(`Backup configuration is invalid: ${validationResult.errors.map(e => e.message).join(', ')}`);\n      }\n      \n      // Write to current config location (assuming enigma.config.js or similar)\n      const configPath = this.findPrimaryConfigPath();\n      if (configPath) {\n        await fs.promises.writeFile(configPath, JSON.stringify(backupConfig, null, 2));\n        this.logger.info('Configuration restored successfully', {\n          configPath,\n          backupPath\n        });\n        \n        this.emit('restored', {\n          configPath,\n          backupPath,\n          config: backupConfig\n        });\n      } else {\n        throw new Error('Could not find primary config file to restore to');\n      }\n      \n    } catch (error) {\n      this.logger.error('Failed to restore from backup', {\n        backupPath,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      \n      throw error;\n    }\n  }\n\n  /**\n   * Setup file watcher event handlers\n   */\n  private setupEventHandlers(): void {\n    if (!this.watcher) return;\n    \n    this.watcher.on('add', (filePath: string) => {\n      this.handleFileEvent('created', filePath);\n    });\n    \n    this.watcher.on('change', (filePath: string) => {\n      this.handleFileEvent('modified', filePath);\n    });\n    \n    this.watcher.on('unlink', (filePath: string) => {\n      this.handleFileEvent('deleted', filePath);\n    });\n    \n    this.watcher.on('error', (error: Error) => {\n      this.logger.error('File watcher error', {\n        error: error.message\n      });\n      \n      this.emit('error', error);\n      \n      // Attempt recovery if enabled\n      if (this.options.enableRecovery) {\n        this.attemptRecovery();\n      }\n    });\n    \n    this.watcher.on('ready', () => {\n      this.logger.info('File watcher ready');\n      this.emit('ready');\n    });\n  }\n\n  /**\n   * Handle file change events with debouncing\n   */\n  private handleFileEvent(type: 'created' | 'modified' | 'deleted', filePath: string): void {\n    // Clear existing timer for this file\n    const existingTimer = this.debounceTimers.get(filePath);\n    if (existingTimer) {\n      clearTimeout(existingTimer);\n    }\n    \n    // Set new debounced timer\n    const timer = setTimeout(() => {\n      this.processFileChange(type, filePath);\n      this.debounceTimers.delete(filePath);\n    }, this.options.debounceMs);\n    \n    this.debounceTimers.set(filePath, timer);\n  }\n\n  /**\n   * Process file change after debouncing\n   */\n  private async processFileChange(type: 'created' | 'modified' | 'deleted', filePath: string): Promise<void> {\n    try {\n      this.logger.debug('Processing config file change', {\n        type,\n        filePath\n      });\n      \n      const event: ConfigChangeEvent = {\n        type,\n        filePath,\n        timestamp: new Date()\n      };\n      \n      // Skip non-config files\n      if (!this.isConfigFile(filePath)) {\n        return;\n      }\n      \n      // Handle deletion\n      if (type === 'deleted') {\n        event.error = new Error('Configuration file deleted');\n        this.emit('change', event);\n        \n        if (this.options.enableRecovery) {\n          this.attemptRecovery();\n        }\n        return;\n      }\n      \n      // Load and validate new configuration\n      try {\n        const newConfig = await loadConfig();\n        event.newConfig = newConfig;\n        \n        if (this.options.validateOnChange) {\n          event.validationResult = await this.validator.validateConfiguration(newConfig);\n          \n          // Apply fallbacks if needed\n          if (this.options.applyFallbacks && event.validationResult && !event.validationResult.isValid) {\n            const safeConfig = this.safetyManager.validateAndApplyFallbacks(newConfig);\n            event.fallbacks = this.safetyManager.getFallbacks();\n            event.newConfig = safeConfig;\n          }\n        }\n        \n        // Create backup if enabled\n        if (this.options.backupOnChange && event.validationResult?.isValid) {\n          await this.createBackup(newConfig);\n        }\n        \n        // Store last valid config\n        if (event.validationResult?.isValid) {\n          this.lastValidConfig = newConfig;\n        }\n        \n      } catch (error) {\n        event.error = error instanceof Error ? error : new Error(String(error));\n        this.logger.warn('Failed to load changed config', {\n          filePath,\n          error: event.error.message\n        });\n      }\n      \n      this.emit('change', event);\n      \n    } catch (error) {\n      this.logger.error('Failed to process file change', {\n        type,\n        filePath,\n        error: error instanceof Error ? error.message : String(error)\n      });