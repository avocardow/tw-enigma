/**\n * Copyright (c) 2025 Rowan Cardow\n * \n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { z } from 'zod';\nimport { createLogger } from './logger.js';\nimport type { EnigmaConfig } from './config.js';\nimport { ConfigError } from './errors.js';\nimport * as os from 'os';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nconst logger = createLogger('ConfigValidator');\n\n/**\n * Performance constraint thresholds\n */\nexport const PERFORMANCE_CONSTRAINTS = {\n  MAX_MEMORY_USAGE_MB: 1024, // 1GB\n  MAX_CONCURRENCY: 8,\n  MIN_FREE_DISK_SPACE_MB: 100,\n  MAX_FILE_SIZE_MB: 100,\n  MAX_TIMEOUT_MS: 30000,\n  WARN_CONCURRENCY_THRESHOLD: 6,\n  WARN_MEMORY_THRESHOLD_MB: 512,\n} as const;\n\n/**\n * Security constraint patterns\n */\nexport const SECURITY_CONSTRAINTS = {\n  FORBIDDEN_PATH_PATTERNS: [\n    /\\.\\.\\//, // Path traversal\n    /\\0/, // Null bytes\n    /[<>:\"|?*]/, // Windows forbidden chars\n    /^[\\s\\.]/, // Leading whitespace or dots\n    /[\\s\\.]$/, // Trailing whitespace or dots\n  ],\n  MAX_PATH_LENGTH: 260, // Windows MAX_PATH\n  FORBIDDEN_DIRECTORIES: [\n    '/etc',\n    '/sys',\n    '/proc',\n    'C:\\\\Windows',\n    'C:\\\\System32',\n  ],\n} as const;\n\n/**\n * Runtime validation result interface\n */\nexport interface ValidationResult {\n  isValid: boolean;\n  warnings: ValidationWarning[];\n  errors: ValidationError[];\n  performanceImpact: PerformanceImpact;\n  securityIssues: SecurityIssue[];\n}\n\n/**\n * Validation warning interface\n */\nexport interface ValidationWarning {\n  type: 'performance' | 'security' | 'compatibility' | 'configuration';\n  message: string;\n  field?: string;\n  suggestion?: string;\n  severity: 'low' | 'medium' | 'high';\n}\n\n/**\n * Validation error interface\n */\nexport interface ValidationError {\n  type: 'constraint' | 'security' | 'dependency' | 'resource';\n  message: string;\n  field?: string;\n  fatal: boolean;\n}\n\n/**\n * Performance impact assessment\n */\nexport interface PerformanceImpact {\n  estimatedMemoryUsage: number; // MB\n  estimatedCpuUsage: 'low' | 'medium' | 'high';\n  estimatedDiskUsage: number; // MB\n  recommendedConcurrency: number;\n  warnings: string[];\n}\n\n/**\n * Security issue interface\n */\nexport interface SecurityIssue {\n  type: 'path_traversal' | 'forbidden_access' | 'unsafe_permissions' | 'resource_exhaustion';\n  message: string;\n  field?: string;\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  mitigation?: string;\n}\n\n/**\n * Configuration constraint validation schema\n */\nexport const ConfigConstraintSchema = z.object({\n  // Performance constraints\n  maxMemoryUsageMB: z.number().min(64).max(PERFORMANCE_CONSTRAINTS.MAX_MEMORY_USAGE_MB).default(512),\n  maxConcurrency: z.number().min(1).max(PERFORMANCE_CONSTRAINTS.MAX_CONCURRENCY).default(4),\n  maxFileSize: z.number().min(1024).max(PERFORMANCE_CONSTRAINTS.MAX_FILE_SIZE_MB * 1024 * 1024).default(10 * 1024 * 1024),\n  maxTimeout: z.number().min(1000).max(PERFORMANCE_CONSTRAINTS.MAX_TIMEOUT_MS).default(10000),\n  \n  // Security constraints\n  allowPathTraversal: z.boolean().default(false),\n  allowSystemDirectories: z.boolean().default(false),\n  enforcePathLimits: z.boolean().default(true),\n  \n  // Resource constraints\n  minFreeDiskSpaceMB: z.number().min(10).default(PERFORMANCE_CONSTRAINTS.MIN_FREE_DISK_SPACE_MB),\n  checkDiskSpace: z.boolean().default(true),\n  checkMemoryAvailable: z.boolean().default(true),\n});\n\nexport type ConfigConstraints = z.infer<typeof ConfigConstraintSchema>;\n\n/**\n * Runtime configuration validator class\n */\nexport class RuntimeConfigValidator {\n  private constraints: ConfigConstraints;\n  private logger = createLogger('RuntimeConfigValidator');\n  \n  constructor(constraints: Partial<ConfigConstraints> = {}) {\n    this.constraints = ConfigConstraintSchema.parse(constraints);\n    this.logger.debug('Runtime validator initialized', {\n      constraints: this.constraints\n    });\n  }\n\n  /**\n   * Validate configuration with comprehensive checks\n   */\n  async validateConfiguration(config: EnigmaConfig): Promise<ValidationResult> {\n    const startTime = Date.now();\n    this.logger.debug('Starting comprehensive configuration validation');\n    \n    const result: ValidationResult = {\n      isValid: true,\n      warnings: [],\n      errors: [],\n      performanceImpact: await this.assessPerformanceImpact(config),\n      securityIssues: [],\n    };\n\n    try {\n      // Cross-field validation\n      await this.validateCrossFields(config, result);\n      \n      // Security validation\n      await this.validateSecurity(config, result);\n      \n      // Performance validation\n      await this.validatePerformance(config, result);\n      \n      // Resource validation\n      await this.validateResources(config, result);\n      \n      // Determine overall validity\n      result.isValid = result.errors.filter(e => e.fatal).length === 0;\n      \n      const duration = Date.now() - startTime;\n      this.logger.info('Configuration validation completed', {\n        isValid: result.isValid,\n        warningCount: result.warnings.length,\n        errorCount: result.errors.length,\n        securityIssues: result.securityIssues.length,\n        duration\n      });\n      \n      return result;\n    } catch (error) {\n      this.logger.error('Configuration validation failed', {\n        error: error instanceof Error ? error.message : String(error)\n      });\n      \n      result.isValid = false;\n      result.errors.push({\n        type: 'constraint',\n        message: `Validation process failed: ${error instanceof Error ? error.message : String(error)}`,\n        fatal: true\n      });\n      \n      return result;\n    }\n  }\n\n  /**\n   * Validate cross-field relationships\n   */\n  private async validateCrossFields(config: EnigmaConfig, result: ValidationResult): Promise<void> {\n    // Ensure output !== input\n    if (config.input && config.output && path.resolve(config.input) === path.resolve(config.output)) {\n      result.errors.push({\n        type: 'configuration',\n        message: 'Input and output paths must be different',\n        field: 'output',\n        fatal: true\n      });\n    }\n\n    // Validate concurrency vs system resources\n    const cpuCount = os.cpus().length;\n    if (config.maxConcurrency > cpuCount * 2) {\n      result.warnings.push({\n        type: 'performance',\n        message: `High concurrency (${config.maxConcurrency}) may exceed system capacity (${cpuCount} CPUs)`,\n        field: 'maxConcurrency',\n        suggestion: `Consider reducing to ${Math.min(cpuCount, 4)}`,\n        severity: 'medium'\n      });\n    }\n\n    // Validate path relationships for CSS injection\n    if (config.cssInjector?.cssPath && config.cssInjector?.htmlPath) {\n      const cssDir = path.dirname(path.resolve(config.cssInjector.cssPath));\n      const htmlDir = path.dirname(path.resolve(config.cssInjector.htmlPath));\n      \n      if (cssDir === htmlDir && config.cssInjector.useRelativePaths === false) {\n        result.warnings.push({\n          type: 'configuration',\n          message: 'CSS and HTML files in same directory - consider using relative paths',\n          field: 'cssInjector.useRelativePaths',\n          suggestion: 'Set useRelativePaths to true',\n          severity: 'low'\n        });\n      }\n    }\n  }\n\n  /**\n   * Validate security constraints\n   */\n  private async validateSecurity(config: EnigmaConfig, result: ValidationResult): Promise<void> {\n    const pathsToCheck = [\n      config.input,\n      config.output,\n      config.cssInjector?.cssPath,\n      config.cssInjector?.htmlPath,\n      config.fileIntegrity?.backupDirectory,\n      ...(config.fileIntegrity?.deduplicationDirectory ? [config.fileIntegrity.deduplicationDirectory] : []),\n      ...(config.fileIntegrity?.incrementalDirectory ? [config.fileIntegrity.incrementalDirectory] : []),\n    ].filter(Boolean) as string[];\n\n    for (const pathToCheck of pathsToCheck) {\n      await this.validatePath(pathToCheck, result);\n    }\n  }\n\n  /**\n   * Validate individual path for security issues\n   */\n  private async validatePath(pathToCheck: string, result: ValidationResult): Promise<void> {\n    // Check for path traversal patterns\n    for (const pattern of SECURITY_CONSTRAINTS.FORBIDDEN_PATH_PATTERNS) {\n      if (pattern.test(pathToCheck)) {\n        result.securityIssues.push({\n          type: 'path_traversal',\n          message: `Potentially unsafe path pattern detected: ${pathToCheck}`,\n          severity: 'high',\n          mitigation: 'Use absolute paths without traversal patterns'\n        });\n      }\n    }\n\n    // Check path length\n    if (pathToCheck.length > SECURITY_CONSTRAINTS.MAX_PATH_LENGTH) {\n      result.securityIssues.push({\n        type: 'forbidden_access',\n        message: `Path exceeds maximum length (${SECURITY_CONSTRAINTS.MAX_PATH_LENGTH}): ${pathToCheck}`,\n        severity: 'medium',\n        mitigation: 'Use shorter path names'\n      });\n    }\n\n    // Check for forbidden directories\n    const resolvedPath = path.resolve(pathToCheck);\n    for (const forbiddenDir of SECURITY_CONSTRAINTS.FORBIDDEN_DIRECTORIES) {\n      if (resolvedPath.startsWith(forbiddenDir)) {\n        result.securityIssues.push({\n          type: 'forbidden_access',\n          message: `Access to system directory forbidden: ${resolvedPath}`,\n          severity: 'critical',\n          mitigation: 'Use user-accessible directories only'\n        });\n      }\n    }\n  }\n\n  /**\n   * Validate performance constraints\n   */\n  private async validatePerformance(config: EnigmaConfig, result: ValidationResult): Promise<void> {\n    // Check concurrency limits\n    if (config.maxConcurrency > this.constraints.maxConcurrency) {\n      result.errors.push({\n        type: 'constraint',\n        message: `Concurrency exceeds limit: ${config.maxConcurrency} > ${this.constraints.maxConcurrency}`,\n        field: 'maxConcurrency',\n        fatal: false\n      });\n    }\n\n    // Check timeout values in nested configs\n    const timeouts = [\n      config.htmlExtractor?.timeout,\n      config.jsExtractor?.timeout,\n      config.cssInjector?.timeout,\n      config.fileIntegrity?.timeout,\n    ].filter(Boolean) as number[];\n\n    for (const timeout of timeouts) {\n      if (timeout > this.constraints.maxTimeout) {\n        result.warnings.push({\n          type: 'performance',\n          message: `High timeout value may cause delays: ${timeout}ms`,\n          suggestion: `Consider reducing to ${this.constraints.maxTimeout}ms`,\n          severity: 'medium'\n        });\n      }\n    }\n\n    // Check file size limits\n    const fileSizes = [\n      config.htmlExtractor?.maxFileSize,\n      config.jsExtractor?.maxFileSize,\n      config.cssInjector?.maxFileSize,\n      config.fileIntegrity?.maxFileSize,\n    ].filter(Boolean) as number[];\n\n    for (const fileSize of fileSizes) {\n      if (fileSize > this.constraints.maxFileSize) {\n        result.warnings.push({\n          type: 'performance',\n          message: `Large file size limit may impact performance: ${Math.round(fileSize / 1024 / 1024)}MB`,\n          suggestion: `Consider reducing to ${Math.round(this.constraints.maxFileSize / 1024 / 1024)}MB`,\n          severity: 'medium'\n        });\n      }\n    }\n  }\n\n  /**\n   * Validate system resources\n   */\n  private async validateResources(config: EnigmaConfig, result: ValidationResult): Promise<void> {\n    if (!this.constraints.checkDiskSpace && !this.constraints.checkMemoryAvailable) {\n      return;\n    }\n\n    try {\n      // Check available memory\n      if (this.constraints.checkMemoryAvailable) {\n        const freeMemory = os.freemem() / 1024 / 1024; // MB\n        const estimatedUsage = result.performanceImpact.estimatedMemoryUsage;\n        \n        if (estimatedUsage > freeMemory * 0.8) {\n          result.warnings.push({\n            type: 'performance',\n            message: `High memory usage estimated: ${estimatedUsage}MB (${Math.round(freeMemory)}MB available)`,\n            suggestion: 'Reduce concurrency or file size limits',\n            severity: 'high'\n          });\n        }\n      }\n\n      // Check disk space for output directories\n      if (this.constraints.checkDiskSpace && config.output) {\n        try {\n          const outputDir = path.dirname(path.resolve(config.output));\n          const stats = await fs.promises.stat(outputDir).catch(() => null);\n          \n          if (!stats) {\n            result.warnings.push({\n              type: 'configuration',\n              message: `Output directory does not exist: ${outputDir}`,\n              field: 'output',\n              suggestion: 'Ensure directory exists or will be created',\n              severity: 'medium'\n            });\n          }\n        } catch (error) {\n          // Non-fatal - just log and continue\n          this.logger.debug('Could not check disk space', {\n            output: config.output,\n            error: error instanceof Error ? error.message : String(error)\n          });\n        }\n      }\n    } catch (error) {\n      this.logger.warn('Resource validation failed', {\n        error: error instanceof Error ? error.message : String(error)\n      });\n    }\n  }\n\n  /**\n   * Assess performance impact of configuration\n   */\n  private async assessPerformanceImpact(config: EnigmaConfig): Promise<PerformanceImpact> {\n    const concurrency = config.maxConcurrency;\n    const hasFileIntegrity = !!config.fileIntegrity;\
    const hasBackups = config.fileIntegrity?.createBackups || false;\n    \n    // Estimate memory usage based on configuration\n    let estimatedMemory = 50; // Base memory\n    estimatedMemory += concurrency * 20; // Per concurrent operation\n    \n    if (hasFileIntegrity) estimatedMemory += 100; // File integrity overhead\n    if (hasBackups) estimatedMemory += 50; // Backup overhead\n    \n    // Estimate CPU usage\n    let cpuUsage: 'low' | 'medium' | 'high' = 'low';\n    if (concurrency > 4) cpuUsage = 'medium';\n    if (concurrency > 6 || hasFileIntegrity) cpuUsage = 'high';\n    \n    // Estimate disk usage\n    let estimatedDisk = 10; // Base disk usage\n    if (hasBackups) estimatedDisk += 100; // Backup storage\n    if (config.fileIntegrity?.enableCompression) estimatedDisk *= 0.7; // Compression savings\n    \n    // Calculate recommended concurrency\n    const cpuCount = os.cpus().length;\n    const recommendedConcurrency = Math.min(Math.max(cpuCount - 1, 1), 4);\n    \n    const warnings: string[] = [];\n    \n    if (estimatedMemory > PERFORMANCE_CONSTRAINTS.WARN_MEMORY_THRESHOLD_MB) {\n      warnings.push(`High memory usage estimated: ${estimatedMemory}MB`);\n    }\n    \n    if (concurrency > PERFORMANCE_CONSTRAINTS.WARN_CONCURRENCY_THRESHOLD) {\n      warnings.push(`High concurrency may impact performance: ${concurrency}`);\n    }\n    \n    return {\n      estimatedMemoryUsage: estimatedMemory,\n      estimatedCpuUsage: cpuUsage,\n      estimatedDiskUsage: estimatedDisk,\n      recommendedConcurrency,\n      warnings\n    };\n  }\n\n  /**\n   * Update constraint settings\n   */\n  updateConstraints(newConstraints: Partial<ConfigConstraints>): void {\n    this.constraints = ConfigConstraintSchema.parse({\n      ...this.constraints,\n      ...newConstraints\n    });\n    \n    this.logger.info('Constraints updated', {\n      newConstraints: Object.keys(newConstraints)\n    });\n  }\n\n  /**\n   * Get current constraints\n   */\n  getConstraints(): ConfigConstraints {\n    return { ...this.constraints };\n  }\n}\n\n/**\n * Create a runtime validator with default constraints\n */\nexport function createRuntimeValidator(constraints?: Partial<ConfigConstraints>): RuntimeConfigValidator {\n  return new RuntimeConfigValidator(constraints);\n}\n\n/**\n * Validate configuration synchronously with basic checks\n */\nexport function validateConfigSync(config: EnigmaConfig): { isValid: boolean; errors: string[] } {\n  const errors: string[] = [];\n  \n  // Basic cross-field validation\n  if (config.input && config.output && path.resolve(config.input) === path.resolve(config.output)) {\n    errors.push('Input and output paths must be different');\n  }\n  \n  // Basic performance checks\n  if (config.maxConcurrency > PERFORMANCE_CONSTRAINTS.MAX_CONCURRENCY) {\n    errors.push(`Concurrency exceeds maximum: ${config.maxConcurrency} > ${PERFORMANCE_CONSTRAINTS.MAX_CONCURRENCY}`);\n  }\n  \n  return {\n    isValid: errors.length === 0,\n    errors\n  };\n} 